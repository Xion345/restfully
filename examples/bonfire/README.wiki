== What is Restfully ==
[http://github.com/crohr/restfully Restfully] is a general-purpose client library for RESTful APIs. It is written in Ruby. Its goal is to abstract the nitty-gritty details of exchanging HTTP requests between the user-agent and the server. It also discovers resources at runtime, which means should the API change and add a new functionality, the client will automatically discover it.

In the next section we will describe how to use Restfully in the specific case of BonFIRE.

== Installation ==
We assume that you're using a unix-based system. For Windows users, you can try to map the instructions to your system, but Restfully has not been tested on Windows.

So, first, be sure you have a version of the <code>Ruby</code> interpreter on your system:

  $ ruby -v
  ruby 1.8.7 (2010-01-10 patchlevel 249) [i686-darwin10.2.0]

If you have a version lower than 1.8.6, you should probably consider upgrading to a newer version.

Then, you need to install <code>Rubygems</code>, the ruby package manager. See http://docs.rubygems.org/read/chapter/3 for more explanations.

Note that on recent distributions (e.g. Debian Squeeze), you should be able to install all that with:

  apt-get update
  apt-get install ruby rubygems libxml-ruby

Then, your Rubygems version (on Debian Squeeze) should be:

  $ gem -v
  1.3.7

Now, install Restfully with:

  $ gem install restfully --prerelease --no-ri --no-rdoc
  Building native extensions.  This could take a while...
  Successfully installed json-1.5.1
  Successfully installed mime-types-1.16
  Successfully installed rest-client-1.6.1
  Successfully installed rack-1.2.2
  Successfully installed rest-client-components-1.2.0
  Successfully installed rack-cache-1.0.1
  Successfully installed backports-2.2.0
  Successfully installed addressable-2.2.6
  Successfully installed restfully-0.7.1.rc2
  9 gems installed

Test that you have access to the Restfully binary:

  $ which restfully
  /var/lib/gems/1.8/bin/restfully

Note: on Debian Squeeze, you may need to add the path to the gem binaries to your $PATH:

  export PATH="/var/lib/gems/1.8/bin:$PATH"

== Getting Started ==

Start the interactive Restfully shell (replace <code>LOGIN</code> and <code>PASSWORD</code> by your BonFIRE credentials):

  $ restfully https://api.bonfire-project.eu:444/ -u LOGIN -p PASSWORD -r ApplicationVndBonfireXml

You should get back a prompt like the following:

  Restfully/0.7.1.rc2 - The root resource is available in the 'root' variable.
  ruby-1.8.7-p249 > 

As indicated, enter <code>root</code> and hit RETURN:

  ruby-1.8.7-p249 > root
   => {"timestamp"=>"1305300530", "version"=>"0.5.1"}

You just fetched the root of the BonFIRE API. You can see the BonFIRE API version (0.5.1) and the server timestamp.
If you want more information of that particular resource, enter <code>pp</code> ('pretty print') followed by your request:

  ruby-1.8.7-p249 > pp root
  #<Resource:0x813f065c uri=https://api.bonfire-project.eu:444/
    RELATIONSHIPS
      experiments, locations, self
    PROPERTIES
      "timestamp"=>"1305300530"
      "version"=>"0.5.1">
   => nil 

The <code>RELATIONSHIPS</code> header contains links to other API resources (here: experiments, locations, self). You can follow any of these links and see what comes back. For instance, following <code>locations</code>:

  ruby-1.8.7-p249 > pp root.locations
  #<Collection:0x813dd534 uri=https://api.bonfire-project.eu:444/locations
    RELATIONSHIPS
      parent, self
    ITEMS (0..5)/5
      #<Resource:0x813c6b04 uri=https://api.bonfire-project.eu:444/locations/be-ibbt>
      #<Resource:0x813b5868 uri=https://api.bonfire-project.eu:444/locations/de-hlrs>
      #<Resource:0x813a45cc uri=https://api.bonfire-project.eu:444/locations/fr-inria>
      #<Resource:0x81393330 uri=https://api.bonfire-project.eu:444/locations/uk-epcc>
      #<Resource:0x81382094 uri=https://api.bonfire-project.eu:444/locations/uk-hplabs>>
   => nil 

It returns the collection of locations available in BonFIRE. If you need to access a specific location, you can either use the <code>find</code> function of Ruby enumerable objects:

  ruby-1.8.7-p249 > pp root.locations.find{|l| l['name'] == 'fr-inria'}
  #<Resource:0x81337e68 uri=https://api.bonfire-project.eu:444/locations/fr-inria
    RELATIONSHIPS
      computes, networks, parent, self, storages
    PROPERTIES
      "name"=>"fr-inria"
      "url"=>"https://bonfire.grid5000.fr:443">
   => nil 

Or use the shortcut method <code>[]</code>, with a symbol as key:

  ruby-1.8.7-p249 > pp root.locations[:'fr-inria']
  #<Resource:0x812e9240 uri=https://api.bonfire-project.eu:444/locations/fr-inria
    RELATIONSHIPS
      computes, networks, parent, self, storages
    PROPERTIES
      "name"=>"fr-inria"
      "url"=>"https://bonfire.grid5000.fr:443">
   => nil 

Again, you see the <code>RELATIONSHIPS</code>, and you can look at any of them by following the links:

  ruby-1.8.7-p249 > pp root.locations[:'fr-inria'].networks
  #<Collection:0x813fff1c uri=https://api.bonfire-project.eu:444/locations/fr-inria/networks
    ITEMS (0..2)/2
      #<Resource:0x813f754c uri=https://api.bonfire-project.eu:444/locations/fr-inria/networks/1>
      #<Resource:0x813f1e6c uri=https://api.bonfire-project.eu:444/locations/fr-inria/networks/2>>
   => nil 

A collection includes the Ruby [http://www.rubydoc.info/stdlib/core/1.9.2/Enumerable <code>Enumerable</code>] module, so you can use any of the functions defined in that module. For instance, pretty-printing each of the networks can be achieved with:

  ruby-1.8.7-p249 > root.locations[:'fr-inria'].networks.each{|net| pp net}
  #<Resource:0x80fed9d8 uri=https://api.bonfire-project.eu:444/locations/fr-inria/networks/1
    RELATIONSHIPS
      self
    PROPERTIES
      "name"=>"Public Network"
      "public"=>"YES"
      "id"=>"1">
  #<Resource:0x80fdb15c uri=https://api.bonfire-project.eu:444/locations/fr-inria/networks/2
    RELATIONSHIPS
      self
    PROPERTIES
      "name"=>"WAN Network"
      "public"=>"YES"
      "id"=>"2">
   => [{"name"=>"Public Network", "public"=>"YES", "id"=>"1"}, {"name"=>"WAN Network", "public"=>"YES", "id"=>"2"}] 

Take your time to follow every relationship you find to see what you get back.  Then in the next section we'll see how we can create things.

== Creating a BonFIRE Experiment ==
You could do all the following using the interactive shell, but it's probably easier to write everything in a script file ready to be executed as many times as you need. For this we'll use the Restfully as a library, and we can write a short script that deploy the required resources for Scenario 1:

  #!/usr/bin/env ruby
  
  require 'rubygems'
  require 'pp'
  require 'restfully'
  
  # Here we use a configuration file to avoid putting our BonFIRE credentials in the source file.
  # See <http://wiki.bonfire-project.eu/index.php/Restfully#FAQ> to learn how to create that configuration file, or at the end of that script.
  session = Restfully::Session.new(
    :configuration_file => "~/.restfully/api.bonfire-project.eu"
  )
  session.logger.level = Logger::INFO
  
  experiment = nil
  
  public_key = Dir[File.expand_path("~/.ssh/*.pub")].find{|key|
    File.exist?(key.gsub(/\.pub$/,""))
  }
  fail "Can't find a public SSH key, with its corresponding private key" if public_key.nil?
  
  puts "Using public key located at #{public_key}."
  
  begin
    experiment = session.root.experiments.submit(
      :name => "Scenario1",
      :description => "Demo of scenario1 using Restfully",
      :walltime => 4*3600 # 4 hours
    )
    
    location1 = session.root.locations[:'fr-inria']
    fail "Can't select the fr-inria location" if location1.nil?
    location2 = session.root.locations[:'de-hlrs']
    fail "Can't select the de-hlrs location" if location2.nil?
    
    server_image = location1.storages.find{|s| s['name'] =~ /squeeze/}
    client_image = location2.storages.find{|s| s['name'] == "Basic Small"}
    fail "Can't get one of the images" if server_image.nil? || client_image.nil?
    
    network_location1 = location1.networks.find{|n| n['public'] == 'YES'}
    fail "Can't select the public network in fr-inria" if network_location1.nil?
    
    network_location2 = location2.networks.find{|n| n['public'] == 'YES'}
    fail "Can't select the network in de-hlrs" if network_location2.nil?
    
    server = experiment.computes.submit(
      :name => "server-experiment##{experiment['id']}",
      :instance_type => "small",
      :disk => [
        {:storage => server_image, :type => "OS"}
      ],
      :nic => [
        {:network => network_location1}
      ],
      :location => location1,
      :context => {
         'AUTHORIZED_KEYS' => File.read(public_key)
       }
    )
    
    client = experiment.computes.submit(
      :name => "client-experiment##{experiment['id']}",
      :instance_type => "small",
      :disk => [
        {:storage => client_image, :type => "OS"}
      ],
      :nic => [
        {:network => network_location2}
      ],
      :location => location2,
      :context => {
         'SERVER_IP' => server.reload['nic'][0]['ip'],
         'AUTHORIZED_KEYS' => File.read(public_key)
       }
    )
    
    # Display VM IPs
    puts "*** Server IP:"
    puts server.reload['nic'][0]['ip']
    
    puts "*** Client IP:"
    puts client.reload['nic'][0]['ip']
    
    # Control loop, until the experiment is done.
    until ['terminated', 'canceled'].include?(experiment.reload['status']) do
      p server.reload
      p client.reload
      
      case experiment['status']
      when 'running'
        puts "Experiment is running. Nothing to do..."
      when 'terminating'
        # Here you could save_as, send a notification, etc.
        # Here for example, we save the first disk of the client VM as a new image:
        client.update(:disk => [
          {:save_as => {:name => "saved-#{client['name']}-image"}}
        ])
      else
        puts "Experiment is #{experiment['status']}. Nothing to do yet."
      end
      sleep 15
    end
    
    puts "Experiment terminated!"
    
  rescue Exception => e
    puts "[ERROR] #{e.class.name}: #{e.message}"
    puts e.backtrace.join("\n")
    puts "Cleaning up..."
    experiment.delete unless experiment.nil?
  end
  
  __END__
  
  $ cat ~/.restfully/api.bonfire-project.eu
  uri: https://api.bonfire-project.eu:444/
  username: crohr
  password: PASSWORD
  require:
    - ApplicationVndBonfireXml
  default_headers:
    Content-Type: application/vnd.bonfire+xml

You could also start SSH sessions after the VMs have been deployed, trigger creation or deletion of VMs when a specific event occurs, etc. All those advanced usages will be described in a future tutorial.
  
== FAQ ==
* How do I avoid passing my password each time I want to use Restfully?

  $ mkdir -p ~/.restfully && echo '
  uri: https://api.bonfire-project.eu:444/
  username: LOGIN
  password: PASSWORD
  require: ['ApplicationVndBonfireXml']
  ' > ~/.restfully/api.bonfire-project.eu.yml && chmod 600 ~/.restfully/api.bonfire-project.eu.yml

Then:

  $ restfully -c ~/.restfully/api.bonfire-project.eu.yml
